<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wumpus World Logical Agent</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/p5.min.js"></script>
    <style>
        body { font-family: sans-serif; background: #f0f0f0; display: flex; justify-content: center; padding: 20px; }
        #game-container { background: white; padding: 20px; border-radius: 8px; box-shadow: 0 4px 15px rgba(0,0,0,0.1); display: flex; gap: 20px; }
        canvas { border: 2px solid #333; background: #c8c8c8; }
        #sidebar { width: 350px; display: flex; flex-direction: column; gap: 10px; }
        .stats-box { background: #eee; padding: 10px; border-radius: 4px; }
        .log-box { flex-grow: 1; background: #333; color: #0f0; padding: 10px; font-family: monospace; font-size: 12px; height: 150px; overflow-y: auto; border-radius: 4px; }
        .controls { display: grid; grid-template-columns: 1fr 1fr; gap: 5px; }
        button { padding: 8px; cursor: pointer; background: #2060ff; color: white; border: none; border-radius: 4px; }
        button:hover { background: #1040cc; }
        button.danger { background: #d9534f; }
        button.success { background: #5cb85c; }
    </style>
</head>
<body>

<!-- Game container holding the canvas and sidebar -->
<div id="game-container">
    <!-- Div for p5.js canvas -->
    <div id="wumpusCanvas"></div>

    <!-- Sidebar with game stats, action log, and control buttons -->
    <div id="sidebar">
        <div class="stats-box">
            <h3 style="margin-top:0">Agent Status</h3>
            <div id="status">Status: Alive</div>
            <div id="score">Score: 0</div>
            <div id="wumpus-status">Wumpus: Alive</div>
            <div id="gold-status">Gold: No</div>
            <div id="arrows">Arrows: 1</div>
            <hr>
            <div id="percepts">Percepts: None</div>
        </div>

        <div class="log-box" id="log">--- NEW WORLD GENERATED ---</div>

        <div class="controls">
            <button onclick="manualAction('MoveForward')">Forward (↑)</button>
            <button onclick="manualAction('Shoot')">Shoot (S)</button>
            <button onclick="manualAction('TurnLeft')">Left (←)</button>
            <button onclick="manualAction('TurnRight')">Right (→)</button>
            <button onclick="manualAction('Grab')">Grab Gold (G)</button>
            <button onclick="manualAction('Climb')">Climb Out (C)</button>
            <button class="success" id="autoBtn" onclick="toggleAutoplay()">Auto-Play (A)</button>
            <button class="danger" onclick="resetGame()">Reset (R)</button>
        </div>
    </div>
</div>

<script>
/** * LOGIC CORE
 */
/** * Agent class with knowledge base and decision making */
class WumpusAgent {
    constructor() {
        this.kb = new Set();
        this.resetState();
    }

    resetState() {
        this.agent_x = 1;
        this.agent_y = 1;
        this.direction = 0;
        this.has_gold = false;
        this.kb.clear();
        this.addFact('V', 1, 1);
        this.addFact('~P', 1, 1);
        this.addFact('~W', 1, 1);
        this.addFact('OK', 1, 1);
    }

    addFact(type, x, y) {
        let symbol;
        if (type.startsWith('~')) {
            symbol = `$¬${type.charAt(1)}_{${x},${y}}$`;
        } else {
            symbol = `$${type}_{${x},${y}}$`;
        }
        this.kb.add(symbol);
    }

    hasFact(type, x, y) {
        let symbol;
        if (type.startsWith('~')) {
            symbol = `$¬${type.charAt(1)}_{${x},${y}}$`;
        } else {
            symbol = `$${type}_{${x},${y}}$`;
        }
        return this.kb.has(symbol);
    }

    removeFact(type, x, y) {
        let symbol;
        if (type.startsWith('~')) {
            symbol = `$¬${type.charAt(1)}_{${x},${y}}$`;
        } else {
            symbol = `$${type}_{${x},${y}}$`;
        }
        this.kb.delete(symbol);
    }

    getNeighbors(x, y) {
        let adj = [[x, y + 1], [x + 1, y], [x, y - 1], [x - 1, y]];
        return adj.filter(([nx, ny]) => nx >= 1 && nx <= 4 && ny >= 1 && ny <= 4);
    }

    tellKB(percepts, x, y) {
        this.agent_x = x; this.agent_y = y;
        this.addFact('V', x, y);
        this.addFact('OK', x, y);
        let logs = [];

        if (percepts.has('Breeze')) {
            this.addFact('B', x, y); this.removeFact('~B', x, y);
            logs.push('* Breeze detected → nearby cells may have pits');
        }
        else {
            this.addFact('~B', x, y); this.removeFact('B', x, y);
            logs.push('* No Breeze detected → nearby cells have no pits');
        }

        if (percepts.has('Stench')) {
            this.addFact('S', x, y); this.removeFact('~S', x, y);
            logs.push('* Stench detected → nearby cells may have the Wumpus');
        }
        else {
            this.addFact('~S', x, y); this.removeFact('S', x, y);
            logs.push('* No Stench detected → nearby cells have no Wumpus');
        }

        if (percepts.has('Glitter')) {
            this.addFact('G', x, y);
            logs.push('* Glitter detected at (' + x + ',' + y + ')');
        }

        return logs;
    }

    inferSafety() {
        let inferences = [];
        for (let x = 1; x <= 4; x++) {
            for (let y = 1; y <= 4; y++) {
                if (this.hasFact('V', x, y)) {
                    let neighbors = this.getNeighbors(x, y);
                    if (this.hasFact('~B', x, y)) {
                        neighbors.forEach(([nx, ny]) => {
                            if (!this.hasFact('~P', nx, ny)) {
                                this.addFact('~P', nx, ny);
                            }
                        });
                    }
                    if (this.hasFact('~S', x, y)) {
                        neighbors.forEach(([nx, ny]) => {
                            if (!this.hasFact('~W', nx, ny)) {
                                this.addFact('~W', nx, ny);
                            }
                        });
                    }
                }
            }
        }
        for (let x = 1; x <= 4; x++) {
            for (let y = 1; y <= 4; y++) {
                if (this.hasFact('~P', x, y) && this.hasFact('~W', x, y) && !this.hasFact('OK', x, y)) {
                    this.addFact('OK', x, y);
                    inferences.push(`* Cell (${x},${y}) inferred as SAFE`);
                }
            }
        }
        return inferences;
    }

    chooseAction(percepts) {
        if (percepts.has('Glitter')) { this.has_gold = true; return 'Grab'; }
        if (this.has_gold && this.agent_x === 1 && this.agent_y === 1) return 'Climb';

        // Find safe unvisited
        let neighbors = this.getNeighbors(this.agent_x, this.agent_y);
        let target = null;
        for (let [nr, nc] of neighbors) {
            if (this.hasFact('OK', nr, nc) && !this.hasFact('V', nr, nc)) {
                target = [nr, nc]; break;
            }
        }

        if (!target && this.has_gold) {
            // Path back to start
            let safeVisited = neighbors.filter(([nr, nc]) => this.hasFact('OK', nr, nc));
            if (safeVisited.length > 0) {
                target = safeVisited.sort((a, b) => (Math.abs(a[0]-1) + Math.abs(a[1]-1)) - (Math.abs(b[0]-1) + Math.abs(b[1]-1)))[0];
            }
        }

        if (target) {
            let [tr, tc] = target;
            let dr = tr - this.agent_x, dc = tc - this.agent_y;
            let targetDir = -1;
            if (dr === -1 && dc === 0) targetDir = 3; // up
            else if (dr === 1 && dc === 0) targetDir = 1; // down
            else if (dr === 0 && dc === 1) targetDir = 0; // right
            else if (dr === 0 && dc === -1) targetDir = 2; // left

            let diff = (targetDir - this.direction + 4) % 4;
            if (diff === 0) return 'MoveForward';
            if (diff === 1) return 'TurnRight';
            if (diff === 3) return 'TurnLeft';
            return 'TurnRight';
        }

        return 'TurnLeft';
    }
}

/** * World class managing the 4x4 grid, agent position, and game state */
class WumpusWorld {
    constructor() {
        this.agent = new WumpusAgent();
        this.setupWorld();
    }

    /** * Initializes the 4x4 grid with pits, wumpus, and gold randomly placed */
    setupWorld() {
        // Initialize empty 4x4 grid
        this.grid = Array.from({ length: 4 }, () => Array.from({ length: 4 }, () => []));
        this.agent_x = 1; this.agent_y = 1;
        this.direction = 0; this.arrows = 1; this.score = 0;
        this.alive = true; this.has_gold = false; this.wumpus_alive = true;
        this.won = false; this.scream = false; this.exited = false;

        let positions = [];
        for(let y=1; y<=4; y++) for(let x=1; x<=4; x++) if(!(x===1 && y===1)) positions.push([x,y]);

        // Pits
        positions = positions.filter(p => {
            if (Math.random() < 0.2) { let [px,py] = p; let r=4-py; let c=px-1; this.grid[r][c].push('P'); return false; }
            return true;
        });
        // Wumpus
        let wPos = positions.splice(Math.floor(Math.random()*positions.length), 1)[0];
        let [wx,wy] = wPos; let wr=4-wy; let wc=wx-1; this.grid[wr][wc].push('W');
        // Gold
        let gPos = positions.splice(Math.floor(Math.random()*positions.length), 1)[0];
        let [gx,gy] = gPos; let gr=4-gy; let gc=gx-1; this.grid[gr][gc].push('G');

        this.agent.resetState();
    }

    /** * Returns the percepts (sensory inputs) for the agent at the given cell */
    getPercepts(x, y) {
        let r = 4 - y; let c = x - 1;
        let p = new Set();
        if (this.grid[r][c].includes('G') && !this.has_gold) p.add('Glitter');
        let adj = [[x, y+1], [x+1, y], [x, y-1], [x-1, y]];
        adj.forEach(([nx, ny]) => {
            if (nx>=1 && nx<=4 && ny>=1 && ny<=4) {
                let nr = 4 - ny; let nc = nx - 1;
                if (this.grid[nr][nc].includes('P')) p.add('Breeze');
                if (this.grid[nr][nc].includes('W') && this.wumpus_alive) p.add('Stench');
            }
        });
        if (this.scream) p.add('Scream');
        return p;
    }

    /** * Processes the agent's action, updates the world state, and returns new percepts and a message */
    processAction(action) {
        if (!this.alive || this.exited) return [new Set(), "Game Over"];
        this.scream = false;
        let msg = "Agent performed: " + action;

        if (action === 'MoveForward') {
            let dx = [1, 0, -1, 0][this.direction];
            let dy = [0, -1, 0, 1][this.direction];
            let nx = this.agent_x + dx, ny = this.agent_y + dy;
            if (nx>=1 && nx<=4 && ny>=1 && ny<=4) {
                this.agent_x = nx; this.agent_y = ny;
                this.agent.agent_x = nx; this.agent.agent_y = ny;
                let r = 4 - ny; let c = nx - 1;
                if (this.grid[r][c].includes('P')) { this.alive = false; this.score -= 1000; msg = "Agent fell into a Pit -> died"; }
                else if (this.grid[r][c].includes('W') && this.wumpus_alive) { this.alive = false; this.score -= 1000; msg = "Agent eaten by Wumpus -> died"; }
            } else msg = "Bumped into wall";
        }
        else if (action === 'TurnLeft') { this.direction = (this.direction + 3) % 4; this.agent.direction = this.direction; }
        else if (action === 'TurnRight') { this.direction = (this.direction + 1) % 4; this.agent.direction = this.direction; }
        else if (action === 'Grab') {
            let r = 4 - this.agent_y; let c = this.agent_x - 1;
            if (this.grid[r][c].includes('G')) {
                this.has_gold = true; this.agent.has_gold = true;
                msg = "Grabbed Gold!";
            }
        }
        else if (action === 'Shoot') {
            if (this.arrows > 0) {
                this.arrows--;
                this.score -= 10;
                let hit = false;
                let x = this.agent_x, y = this.agent_y;
                while (true) {
                    // Move in shooting direction
                    if (this.direction === 0) x++; // right
                    else if (this.direction === 1) y--; // down
                    else if (this.direction === 2) x--; // left
                    else if (this.direction === 3) y++; // up

                    if (x < 1 || x > 4 || y < 1 || y > 4) break; // hit wall
                    let r = 4 - y; let c = x - 1;
                    if (this.grid[r][c].includes('W')) {
                        hit = true;
                        break; // hit wumpus
                    }
                }
                if (hit) {
                    this.wumpus_alive = false;
                    this.score += 1000;
                    this.scream = true;
                    msg = "Killed Wumpus!";
                } else {
                    msg = "Shot missed";
                }
            } else {
                msg = "No arrows left";
            }
        }
        else if (action === 'Climb') {
            if (this.agent_x === 1 && this.agent_y === 1) {
                this.exited = true;
                if (this.has_gold) { this.score += 1000; this.won = true; }
                msg = "Climbed out!";
            }
        }

        if (action !== 'Climb') this.score--;
        return [this.getPercepts(this.agent_x, this.agent_y), msg];
    }
}

/** * UI RENDERING
 */
let world = new WumpusWorld();
let autoplayInterval = null;
let agentImages = [];
let goldImage;
let wumpusImage;
let pitImage;

function preload() {
  agentImages[0] = loadImage('right.png');
  agentImages[1] = loadImage('front.png');
  agentImages[2] = loadImage('left.png');
  agentImages[3] = loadImage('up.png');
  goldImage = loadImage('gold.png');
  wumpusImage = loadImage('wumpus.png');
  pitImage = loadImage('pit.png');
}

function setup() {
  createCanvas(400, 400).parent('wumpusCanvas');
  noLoop();
}

/** * Updates the UI elements with current game state and logs messages */
function updateUI(msg, inferences = []) {
    document.getElementById('score').innerText = `Score: ${world.score}`;
    let status = "Alive";
    if (world.exited) status = world.won ? "Winner! Exited" : "Exited";
    else if (!world.alive) status = "Dead";
    document.getElementById('status').innerText = `Status: ${status}`;
    document.getElementById('wumpus-status').innerText = `Wumpus: ${world.wumpus_alive ? "Alive" : "Dead"}`;
    document.getElementById('gold-status').innerText = `Gold: ${world.has_gold ? "Yes" : "No"}`;
    document.getElementById('arrows').innerText = `Arrows: ${world.arrows}`;

    let p = world.getPercepts(world.agent_x, world.agent_y);
    document.getElementById('percepts').innerText = `Percepts: ${Array.from(p).join(', ') || 'None'}`;

    let log = document.getElementById('log');
    if (msg) {
        log.innerHTML += `<br>> ${msg}`;
    }
    if (inferences && inferences.length > 0) {
        inferences.forEach(inf => log.innerHTML += `<br>> ${inf}`);
    }
    if (msg || inferences.length > 0) {
        log.scrollTop = log.scrollHeight;
    }
    redraw();
}

/** * Renders the 4x4 grid cells with colors, symbols, content, and the agent */
function draw() {
    background('#c8c8c8');
    const sz = 100;

    for (let y_coord = 4; y_coord >= 1; y_coord--) {
        for (let x_coord = 1; x_coord <= 4; x_coord++) {
            let r = 4 - y_coord;
            let c = x_coord - 1;
            let px = c * sz;
            let py = r * sz;

            // Background color based on KB
            let color = "#c8c8c8";
            if (world.agent.hasFact('V', x_coord, y_coord)) color = "#c8dcff";
            if (world.agent.hasFact('OK', x_coord, y_coord)) color = "#96ff96";
            if (x_coord === world.agent_x && y_coord === world.agent_y) color = "#ffff64";

            fill(color);
            rect(px, py, sz, sz);
            stroke(0);
            strokeWeight(1);
            noFill();
            rect(px, py, sz, sz);

            // Real Content (for visited cells)
            if (world.agent.hasFact('V', x_coord, y_coord)) {
                let items = world.grid[r][c];
                if (items.includes('P')) image(pitImage, px + 25, py + 25, 50, 50);
                if (items.includes('W')) image(wumpusImage, px + 5, py + 5, 90, 90);
                if (items.includes('G') && !world.has_gold) image(goldImage, px + 25, py + 25, 50, 50);
            }

            // Show percepts for visited cells
            if (world.agent.hasFact('V', x_coord, y_coord)) {
                let percepts = world.getPercepts(x_coord, y_coord);
                if (percepts.size > 0) {
                    textSize(10);
                    textFont('sans-serif');
                    fill(0);
                    text(Array.from(percepts).join(', '), px+5, py+sz-10);
                }
            }
        }
    }

    // Draw Agent Image
    let ax = (world.agent_x - 1) * sz + 50;
    let ay = (4 - world.agent_y) * sz + 50;
    image(agentImages[world.direction], ax - 25, ay - 25, 50, 50);
}

function manualAction(act) {
    if (!world.alive || world.exited) return;
    let [p, msg] = world.processAction(act);
    let perceptLogs = world.agent.tellKB(p, world.agent_x, world.agent_y);
    let inferences = world.agent.inferSafety();
    let allLogs = perceptLogs.concat(inferences);
    updateUI(msg, allLogs);
}

function resetGame() {
    world.setupWorld();
    document.getElementById('log').innerHTML = "--- NEW WORLD GENERATED ---";
    let p = world.getPercepts(world.agent_x, world.agent_y);
    let perceptLogs = world.agent.tellKB(p, world.agent_x, world.agent_y);
    let inferences = world.agent.inferSafety();
    updateUI(null, perceptLogs.concat(inferences));
}

function toggleAutoplay() {
    if (autoplayInterval) {
        clearInterval(autoplayInterval);
        autoplayInterval = null;
        document.getElementById('autoBtn').innerText = "Auto-Play (A)";
    } else {
        document.getElementById('autoBtn').innerText = "Stop (A)";
        autoplayInterval = setInterval(() => {
            if (!world.alive || world.exited) { toggleAutoplay(); return; }
            let p = world.getPercepts(world.agent_x, world.agent_y);
            let act = world.agent.chooseAction(p);
            manualAction(act);
        }, 500);
    }
}

// Event listener for keyboard controls
window.addEventListener('keydown', e => {
    if (e.key === 'ArrowUp') manualAction('MoveForward');
    if (e.key === 'ArrowLeft') manualAction('TurnLeft');
    if (e.key === 'ArrowRight') manualAction('TurnRight');
    if (e.key === 'g') manualAction('Grab');
    if (e.key === 's') manualAction('Shoot');
    if (e.key === 'c') manualAction('Climb');
    if (e.key === 'r') resetGame();
    if (e.key === 'a') toggleAutoplay();
});

resetGame();
</script>
</body>
</html>
